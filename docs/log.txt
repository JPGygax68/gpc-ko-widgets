2014-03-10
==========

- Interesting: http://philipnilsson.github.io/Badness10k/articles/knockout-patterns-proxy/

-----------

A note about the "value" column in the present implementation, for future reference:

- The "value" column is an optional feature of the treeview, and can be enabled via the showValueColumn() observable
- The tree view cannot display anything in the value column by itself, though it does generate a container element for each cell (currently a TD); it delegates the rendering of values to the KO template that can be specified for each node via the valueTemplateName() observable
- There is currently no observable or treeview-specific CSS rules to set the width of the value column.

----------

It's too late in the evening now to get started on implementing node insertion, but it'll have to be done soon. Here are my thoughts about it at this time:

- There must be a way to create the actual item being added. 
  - The filter() callback offers an opportunity to attach the relevant code to a parent node. Drawback: the separation of concerns is not clean: the responsibility for creating items should lie with its container (reminder: a node's children member is not the original container, more like a reflection of it)
  - Attaching a createItem() function to the "real" observableArray() is also a possibility. The drawback with that is that it requires user code in one more place, i.e. in the callback passed to ko.mapping.fromJS() (for example).

(Of course, there is nothing wrong with implementing both.)

Another way to look at it is that JS arrays, by themselves, are simply not intended to be full-fledged collections. It would be very interesting, in the future, to integrate the tree view widget with Backbone (possibly using Knockback?), which should have all required features. In the meantime though, I guess it would be perfectly acceptable to use node-attached code to complement plain observableArrays with the code necessary to make insertion/deletion work.


2014-03-09
==========

About models (not view models) with two-way binding capability:

- Extending observables! http://knockoutjs.com/documentation/fn.html

- Knockback could probably provide the models that I need, but it seems like overkill.
  -> https://github.com/thelinuxlich/knockout.model  ?
  -> https://coderwall.com/p/bzmrja ?
  
-----------

- The newer version of Knockout have an observableArray subscription "arrayChange" that should cover my needs (done a quick-and-dirty experiment).

- About the labels of array elements: they should not necessarily indicate the index. Use the fromModel() filter callback for that (e.g. computed observable) [DONE for the "adjustments" array (and fixed a bug along the way)]
  
2014-03-08
==========

I've successfully gotten started on implementing keyboard commands (navigation only, so far).

Next steps:

- Although fromModel(), the (temporary?) replacement for fromJSON() now accepts KO observables, I haven't implemented bidirectional synchronization yet. However this is crucial for the tree view (and widgets generally) to reach production level, so I should do this next.
  - I'm not sure it's possible/practical for items being added to / removed from an object (non-array), since there is no equivalent to observableArray for objects.
  - Unidirectional updates (from the tree to the model) could be implemented using an extended version of observableArray:
    https://groups.google.com/forum/#!topic/knockoutjs/RLzj244VGSo
    Thinking about it, it could be made bidirectional by making ko.mapping use that extended version of observableArray as well.
    - Care must be taken to avoid update loops. This could be done by concatenating "routes" (as arrays of objects); a simple indexOf() would then tell whether the current object could be the origin of the change notification.

- Detail: having to use the ctrl modifier to open and close nodes is not really intuitive now that the up & down keys will cross levels. [CHANGED. At least I was able to test key combinations.]


2014-03-07
==========

- Customize Node objects by assigning a "prototype" ?
  -> no longer create default node instances in advance ? create it afterwards unless the filter function provides one
  
- Provide hooks in Node - as virtual methods or as events ?

- Provide CollectionNode, HashNode, ValueNode derived classes ?

---------------

- fromJSON() replaced with fromModel() which is capable of working with observable-wrapped data (as obtained from ko.mapping())

What is called for now is a way to add columns; or at least, for now, to apply knockout templates to cells in the "value" column. 

This should be possible using Knockout named templates. I'm going to start by providing three very basic templates for numbers, booleans, and strings.

Fine-tuning appearance and behaviour could be done through the use of $parent, which would, in the context of a value "cell" template, access the containing node object.

---------

I've done the above experimentally, it appears to work well.

Next steps:

- Implement keyboard navigation

- decide whether to support multiple "custom columns" or just a single one. I'm leaning towards a single one, which user code can then fill by itself
  - The "extension column" is enabled by a property of each node, which specifies the name of the template to use.

- Support read-only cells
  - The simplest option is simply not to wrap those values as observables.
  - Other options (a meta-info callback ?) could be implemented later

- I need a means to add and delete items to and from arrays. For the time being, it will suffice if this can only be done through the keyboard [and if I get around to implement "actions" and keyboard shortcuts, this may eliminate the need to provide specific UI elements]. Validating and sorting should be doable via the mapping.fromJS() callbacks (using multi-level "mapping" properties).

- I also want to provide, as a convenience, a few super-simple predefined named templates for numbers, booleans and strings 
  - How to pass in the metadata (min, max, etc.) ?

It may turn out to be necessary to wrap cells into standardized span's after all. In that case, it would also be necessary to implement a node type registry. Each node's type would then determine what additional columns it displays.

I rather hope to avoid this. It would mean a lot of work for something that is beyond the scope of a simple tree view. Each extended row would, in effect, be treated like a sub-widget; and ko.mapping.fromJS's "create" hook provides the golden opportunity to create custom nodes, by using classes derived from Node.

- FUTURE: support "container" child nodes that do not have a name and can contain anything

2014-03-05
==========

- It may be interesting to investigate an alternative way to layout the tree view, based on CSS table styling. This depends on whether or not it is possible to "wrap" table-row-group elements.

- As an alternative, just use tables (or equivalently styled elements) as they are supposed to and use generated class tags to show/hide node content.

The advantage of any of these methods (only the second would probably work) is that layout can be done by CSS alone.

UPDATE: I have found and implemented a way to do it CSS-only with the current approach by wrapping the "main" part of each node header and setting the width of that.

--------------

UPDATE #2: back to computed indenting - easier in the end. Implementing ellipses for labels was tricky, it required using tables because inline-block elements that have overflow != visible cannot align on the baseline (for no reason I can understand).


2014-03-03
==========

- fromJSON(): option to automatically make children-less object into leaf nodes ?

- Should nodes be Observables ? 
- Should children array be an observableArray ?

- Option to leave out non-object (implying non-array) items ?

- Implement a way to order children

- Implement extra columns

- Implement two-way binding (with callback to enable updating)

- Implement a way to delay loading of contents
  - Possibly give visual feedback to distinguish between "has children" and "content not loaded yet" ?

2014-03-02
==========

- distinguish between nodes that are necessarily leafs and those that could have children but don't for the time being

2014-03-01
==========

Lots of todos:

- option to include root node

- open/close - mouse or keyboard 
  -> what about tab behavior ?
  
- callback function(s) to customize fromJSON()
  - "default property" (typically an array) that is represented by its parent node ?

- ability to attach additional "columns"

- emit events when node is entered or exited; same for hover

Misc:

- Is it possible to have knockout remove/omit the structural stuff when generating DOM content from templates ?

---------------

- The root node is actually already being rendered, but without a label

2014-02-27
==========

- I've fallen back for now to adding the knockout templates by including a single Jade include file. But I think I will replace this with a browserify or RequireJS plugin to read in the code as text, then use document.write() to inject those templates into the DOM (alternative: override ko.templateEngine.makeTemplateSource()).

2014-02-26
==========

- It starts to look like Injector will really be necessary; adding knockout templates by hand is incredibly tedious.



2014-02-25
==========

Project description
-------------------

This is where I'm going to develop and maintain my library of reusable widgets based on Knockout, Jade, and Stylus; plus possibly jQuery-UI.

The idea is not to create something incredibly sophisticated here (though it may develop into just that in time), but rather to keep it as simple as possible.

In terms of the triad of building blocks mentioned above, this means:

- Use Knockout as the mechanism binding data to visual (i.e. DOM) elements; in particular, use Knockout "templates" to create reusable building blocks.

- Use Jade as the means to bring knockout templates into the HTML (as pseudo-script elements) and provide mixins that generate app-specific DOM subtrees (e.g. forms)


First step: a Tree View to navigate a JSON data object
------------------------------------------------------

(Project ls-instr-editor)

JSON data is comprised of nodes, each containing named properties that can be either simple data values, other nodes or arrays.

The challenge is to make this into a useful tree view without having the code getting overly complex.

Knockout's named template mechanism provides a possibility here: have a property in each node of the view model that determines which of the available node-rendering templates should be used for that particular node.

[Another question is how to get node-specific content into the tree view (though that may be for a future version). It could be done through viewmodel properties with HTML content; precompiled Jade templates can help here - the question is whether those can contain Knockout in turn. Or is it necessary (and possible ?) to generate named templates on-the-fly?]

Concretizing
------------

Let's call our visual components "widgets". What's in a widget ?

- There is Jade source code common to all instances of the widget. This code defines:
  a) the named templates that widget instances' building blocks may use
  b) the mixins defining the building blocks
  c) CSS include directives [not sure yet - it may be easier to let users add the link rel themselves]

- There is Stylus source code, defining the CSS required by the widget instances.

- There is JavaScript code:
  - There may be JS code defining a custom binding. [This will probably not be required for all widgets.]
  - There may be event handlers (afterRender, afterAdd, beforeRemove)
  
Output file structure
---------------------

This is the structure the fully built widget library should have:

dist 
  common
    css
      style.css
    javascript
      gpc-ko-widgets.js
    html
      <block1>.html
  <widget1>
    css
      <widget>.css
    javascript
      <widget>.js
    templates
      <widget>.html
      <block1>.html
      <block2>.html
      templates.jade
  <widget2>
  ...
  <widget_n>


The top-level DOM element of every widget is assigned two classes, "gpc-ko-widget" plus the name of the widget itself, e.g. "treeview".

The common/css/style.css file contains style definitions common to all GPC Knockout widgets.

The file gpc-ko-widgets.js exports the object "gpc", which will contain a subobject "ko_widgets". The latter is the namespace object for this library.

The <widget>.css file contains style rules specific to the widget.

The <widget>.js file registers the custom binding (if any). It may also add members to the gpc.ko_widgets namespace object.

Each of the .html files under "templates" contains a single template that may be used by the widget. Its ID is prefixed with "gpckow-<widget>-". 

The special file templates.jade can be included from a Jade source file. It will do the same thing as adding external script tags for each of the .html files under "templates".

Javascript code will not be packaged, neither in CommonJS nor in AMD format. I'd like to make shimming as straightforward as possible though.


About the development process
-----------------------------

There shall be a test page (or sub-page) for each widget, with at least one test case each. More sophisticated testing (Karma?) may be added later.

Building will be done using Gulp (initially - maybe something better will turn up later).

























